<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js 卫星环绕月球</title>
    <style>
      html, body { height: 100%; }
      body {
        margin: 0;
        background: radial-gradient(120% 120% at 50% 20%, #0b1226, #060913 60%, #03070f 100%);
        overflow: hidden;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, PingFang SC, "Microsoft YaHei", Arial, sans-serif;
        color: #cdd6f4;
      }
      #app { position: fixed; inset: 0; }
      .hud {
        position: fixed;
        left: 12px;
        bottom: 12px;
        background: #0b1226aa;
        border: 1px solid #ffffff22;
        padding: 8px 10px;
        border-radius: 8px;
        font-size: 12px;
        backdrop-filter: blur(6px);
        user-select: none;
      }
      .hud kbd{background:#1e293b; border:1px solid #334155; padding:2px 6px; border-radius:4px; font-size:11px}
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hud">拖拽旋转视角，滚轮缩放；按住 <kbd>Shift</kbd> 平移</div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'https://unpkg.com/three@0.160.0/examples/jsm/controls/OrbitControls.js';

      // 基本场景
      const container = document.getElementById('app');
      const scene = new THREE.Scene();

      // 星空：大量点云
      function createStars(count = 2000, radius = 150) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        for (let i = 0; i < count; i++) {
          // 均匀分布在球壳附近
          const r = radius * (0.7 + 0.3 * Math.random());
          const theta = Math.acos(THREE.MathUtils.randFloatSpread(2));
          const phi = THREE.MathUtils.randFloatSpread(Math.PI * 2);
          positions[i * 3 + 0] = r * Math.sin(theta) * Math.cos(phi);
          positions[i * 3 + 1] = r * Math.cos(theta);
          positions[i * 3 + 2] = r * Math.sin(theta) * Math.sin(phi);
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        const material = new THREE.PointsMaterial({
          size: 0.6,
          sizeAttenuation: true,
          color: 0xffffff,
          opacity: 0.85,
          transparent: true,
          depthWrite: false
        });
        const points = new THREE.Points(geometry, material);
        points.renderOrder = -1;
        return points;
      }
      scene.add(createStars());

      // 相机与渲染器
      const camera = new THREE.PerspectiveCamera(55, 1, 0.1, 1000);
      camera.position.set(8, 5, 10);
      camera.lookAt(0, 0, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  // 第三个参数使用默认值（true），同步更新 <canvas> 的 CSS 尺寸，确保全屏
  renderer.setSize(container.clientWidth, container.clientHeight);
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.toneMappingExposure = 1.0;
      container.appendChild(renderer.domElement);

      // 控制器
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.minDistance = 4;
      controls.maxDistance = 60;

      // 光照
      const ambient = new THREE.AmbientLight(0xffffff, 0.35);
      scene.add(ambient);
      const dir = new THREE.DirectionalLight(0xffffff, 1.1);
      dir.position.set(6, 4, 2);
      dir.castShadow = false;
      scene.add(dir);

      // 月球
      const moonRadius = 2.0;
      const moonGeo = new THREE.SphereGeometry(moonRadius, 64, 64);
      const moonMat = new THREE.MeshStandardMaterial({
        color: 0xd9dde4,
        roughness: 0.85,
        metalness: 0.0,
        emissive: 0x111111,
        emissiveIntensity: 0.15
      });
      const moon = new THREE.Mesh(moonGeo, moonMat);
      scene.add(moon);

      // 月晕（柔光气辉）
      const glowGeo = new THREE.SphereGeometry(moonRadius * 1.08, 48, 48);
      const glowMat = new THREE.MeshBasicMaterial({
        color: 0xbcd0ff,
        transparent: true,
        opacity: 0.12,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
      const glow = new THREE.Mesh(glowGeo, glowMat);
      scene.add(glow);

      // 卫星（小球）与轨道
      const orbitRadius = moonRadius + 2.6; // 轨道半径
      const satGeo = new THREE.SphereGeometry(0.28, 32, 32);
      const satMat = new THREE.MeshStandardMaterial({ color: 0x86b7ff, roughness: 0.4, metalness: 0.1 });
      const satellite = new THREE.Mesh(satGeo, satMat);

      // 枢轴对象，用其旋转来驱动公转
      const pivot = new THREE.Object3D();
      pivot.add(satellite);
      scene.add(pivot);
      satellite.position.set(orbitRadius, 0, 0);

      // 轨道环（细托鲁斯）
      const ringGeo = new THREE.TorusGeometry(orbitRadius, 0.01, 8, 256);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.35 });
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI / 2; // 放到 XZ 平面
      scene.add(ring);

      // 可选：略微倾角
      const tilt = THREE.MathUtils.degToRad(12);
      pivot.rotation.z = tilt; // 轨道倾角
      ring.rotation.z = tilt;

      // 动画
      const clock = new THREE.Clock();
  let orbitSpeed = 0.35;   // 公转速度（弧度/秒）
  let spinSpeed  = 0.10;   // 月球自转速度

      function onResize(){
        const { clientWidth:w, clientHeight:h } = container;
  camera.aspect = w / h; camera.updateProjectionMatrix();
  renderer.setSize(w, h); // 同步更新 CSS 尺寸，保证画布铺满
      }
      window.addEventListener('resize', onResize);
      onResize();

      function animate(){
        const dt = clock.getDelta();
        pivot.rotation.y += orbitSpeed * dt; // 卫星公转
        moon.rotation.y  += spinSpeed  * dt; // 月球自转
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // 无障碍：减少动画时降速
      const mq = window.matchMedia('(prefers-reduced-motion: reduce)');
      if (mq.matches) {
        orbitSpeed = 0; spinSpeed = 0; // 尊重用户动效偏好
      }
    </script>
  </body>
  </html>
