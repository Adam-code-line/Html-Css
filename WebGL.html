<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>WebGL Animated Circle</title>
	<style>
		body {
			margin: 0;
			background: #0f172a;
			color: #e2e8f0;
			font-family: Arial, sans-serif;
			display: flex;
			flex-direction: column;
			align-items: center;
			justify-content: center;
			min-height: 100vh;
			gap: 1.5rem;
		}

		canvas {
			width: 480px;
			height: 480px;
			border: 1px solid rgba(148, 163, 184, 0.35);
			border-radius: 12px;
			box-shadow: 0 18px 38px rgba(15, 23, 42, 0.45);
			background: radial-gradient(circle at center, rgba(59, 130, 246, 0.2), rgba(15, 23, 42, 0.8));
		}
	</style>
</head>
<body>
	<canvas id="glcanvas" width="480" height="480"></canvas>

	<script>
		const canvas = document.getElementById('glcanvas')
		const gl = canvas.getContext('webgl')

		if (!gl) {
			alert('Unable to initialise WebGL. Your browser may not support it.')
		}

		const vertexSource = `
			attribute vec3 aPosition;
			attribute vec3 aNormal;
			uniform mat4 uProjectionMatrix;
			uniform mat4 uModelMatrix;
			uniform mat3 uNormalMatrix;
			varying vec3 vNormal;
			void main() {
				vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);
				vNormal = normalize(uNormalMatrix * aNormal);
				gl_Position = uProjectionMatrix * worldPosition;
			}
		`

		const fragmentSource = `
			precision mediump float;
			uniform vec3 uBaseColor;
			uniform vec3 uAmbientColor;
			uniform vec3 uLightDirection;
			varying vec3 vNormal;
			void main() {
				vec3 normal = normalize(vNormal);
				float diffuse = max(dot(normal, normalize(-uLightDirection)), 0.0);
				vec3 color = uAmbientColor + uBaseColor * diffuse;
				gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
			}
		`

		function compileShader(type, source) {
			const shader = gl.createShader(type)
			gl.shaderSource(shader, source)
			gl.compileShader(shader)
			if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
				const info = gl.getShaderInfoLog(shader)
				gl.deleteShader(shader)
				throw new Error('Could not compile shader:\n' + info)
			}
			return shader
		}

		const vertexShader = compileShader(gl.VERTEX_SHADER, vertexSource)
		const fragmentShader = compileShader(gl.FRAGMENT_SHADER, fragmentSource)

		const program = gl.createProgram()
		gl.attachShader(program, vertexShader)
		gl.attachShader(program, fragmentShader)
		gl.linkProgram(program)

		if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
			const info = gl.getProgramInfoLog(program)
			gl.deleteProgram(program)
			throw new Error('Could not link WebGL program:\n' + info)
		}

		gl.useProgram(program)

		function createSphere(radius, latBands, longBands) {
			const positions = []
			const normals = []
			const indices = []

			for (let lat = 0; lat <= latBands; lat += 1) {
				const theta = (lat * Math.PI) / latBands
				const sinTheta = Math.sin(theta)
				const cosTheta = Math.cos(theta)

				for (let lon = 0; lon <= longBands; lon += 1) {
					const phi = (lon * 2 * Math.PI) / longBands
					const sinPhi = Math.sin(phi)
					const cosPhi = Math.cos(phi)

					const x = cosPhi * sinTheta
					const y = cosTheta
					const z = sinPhi * sinTheta

					normals.push(x, y, z)
					positions.push(radius * x, radius * y, radius * z)
				}
			}

			for (let lat = 0; lat < latBands; lat += 1) {
				for (let lon = 0; lon < longBands; lon += 1) {
					const first = lat * (longBands + 1) + lon
					const second = first + longBands + 1

					indices.push(first, second, first + 1)
					indices.push(second, second + 1, first + 1)
				}
			}

			return {
				positions: new Float32Array(positions),
				normals: new Float32Array(normals),
				indices: new Uint16Array(indices)
			}
		}

		const sphere = createSphere(0.9, 48, 64)

		const positionBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, sphere.positions, gl.STATIC_DRAW)

		const normalBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
		gl.bufferData(gl.ARRAY_BUFFER, sphere.normals, gl.STATIC_DRAW)

		const indexBuffer = gl.createBuffer()
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer)
		gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.indices, gl.STATIC_DRAW)

		const positionLocation = gl.getAttribLocation(program, 'aPosition')
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer)
		gl.enableVertexAttribArray(positionLocation)
		gl.vertexAttribPointer(positionLocation, 3, gl.FLOAT, false, 0, 0)

		const normalLocation = gl.getAttribLocation(program, 'aNormal')
		gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer)
		gl.enableVertexAttribArray(normalLocation)
		gl.vertexAttribPointer(normalLocation, 3, gl.FLOAT, false, 0, 0)

		const projectionLocation = gl.getUniformLocation(program, 'uProjectionMatrix')
		const modelLocation = gl.getUniformLocation(program, 'uModelMatrix')
		const normalMatrixLocation = gl.getUniformLocation(program, 'uNormalMatrix')
		const baseColorLocation = gl.getUniformLocation(program, 'uBaseColor')
		const ambientColorLocation = gl.getUniformLocation(program, 'uAmbientColor')
		const lightDirectionLocation = gl.getUniformLocation(program, 'uLightDirection')

		gl.enable(gl.DEPTH_TEST)
		gl.enable(gl.CULL_FACE)
		gl.cullFace(gl.BACK)

		gl.uniform3fv(ambientColorLocation, new Float32Array([0.08, 0.1, 0.18]))
		gl.uniform3fv(lightDirectionLocation, new Float32Array([0.5, 0.7, 1.0]))

		function perspective(out, fovy, aspect, near, far) {
			const f = 1.0 / Math.tan(fovy / 2)
			out[0] = f / aspect
			out[1] = 0
			out[2] = 0
			out[3] = 0

			out[4] = 0
			out[5] = f
			out[6] = 0
			out[7] = 0

			out[8] = 0
			out[9] = 0
			out[10] = (far + near) / (near - far)
			out[11] = -1

			out[12] = 0
			out[13] = 0
			out[14] = (2 * far * near) / (near - far)
			out[15] = 0
			return out
		}

		function identity(out) {
			out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0
			out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0
			out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0
			out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1
			return out
		}

		function multiply(out, a, b) {
			const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3]
			const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7]
			const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11]
			const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15]

			const b00 = b[0], b01 = b[1], b02 = b[2], b03 = b[3]
			const b10 = b[4], b11 = b[5], b12 = b[6], b13 = b[7]
			const b20 = b[8], b21 = b[9], b22 = b[10], b23 = b[11]
			const b30 = b[12], b31 = b[13], b32 = b[14], b33 = b[15]

			out[0] = a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30
			out[1] = a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31
			out[2] = a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32
			out[3] = a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33

			out[4] = a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30
			out[5] = a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31
			out[6] = a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32
			out[7] = a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33

			out[8] = a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30
			out[9] = a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31
			out[10] = a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32
			out[11] = a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33

			out[12] = a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30
			out[13] = a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31
			out[14] = a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32
			out[15] = a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33
			return out
		}

		function rotationY(out, angle) {
			const c = Math.cos(angle)
			const s = Math.sin(angle)
			identity(out)
			out[0] = c
			out[2] = s
			out[8] = -s
			out[10] = c
			return out
		}

		function rotationX(out, angle) {
			const c = Math.cos(angle)
			const s = Math.sin(angle)
			identity(out)
			out[5] = c
			out[6] = -s
			out[9] = s
			out[10] = c
			return out
		}

		function translation(out, x, y, z) {
			identity(out)
			out[12] = x
			out[13] = y
			out[14] = z
			return out
		}

		const projectionMatrix = new Float32Array(16)
		const rotationYMatrix = new Float32Array(16)
		const rotationXMatrix = new Float32Array(16)
		const rotationMatrix = new Float32Array(16)
		const translationMatrix = new Float32Array(16)
		const modelMatrix = new Float32Array(16)
		const normalMatrix3 = new Float32Array(9)

		function resizeCanvasToDisplaySize(canvas) {
			const displayWidth = canvas.clientWidth
			const displayHeight = canvas.clientHeight
			if (canvas.width !== displayWidth || canvas.height !== displayHeight) {
				canvas.width = displayWidth
				canvas.height = displayHeight
			}
		}

		function extractNormalMatrix(out, mat) {
			out[0] = mat[0]; out[1] = mat[1]; out[2] = mat[2]
			out[3] = mat[4]; out[4] = mat[5]; out[5] = mat[6]
			out[6] = mat[8]; out[7] = mat[9]; out[8] = mat[10]
			return out
		}

		function render(time) {
			resizeCanvasToDisplaySize(canvas)

			gl.viewport(0, 0, canvas.width, canvas.height)
			gl.clearColor(0.03, 0.06, 0.12, 1)
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT)

			const aspect = canvas.width / canvas.height
			const fov = Math.PI / 3
			perspective(projectionMatrix, fov, aspect, 0.1, 10)

			const t = time * 0.001

			rotationY(rotationYMatrix, t * 0.5)
			rotationX(rotationXMatrix, Math.sin(t * 0.7) * 0.5)
			multiply(rotationMatrix, rotationYMatrix, rotationXMatrix)
			translation(translationMatrix, 0, 0, -2.4)

			multiply(modelMatrix, translationMatrix, rotationMatrix)

			const baseColor = [
				0.35 + 0.25 * Math.sin(t * 1.3),
				0.55 + 0.2 * Math.sin(t * 1.1 + 1.2),
				0.9
			]

			extractNormalMatrix(normalMatrix3, rotationMatrix)

			gl.uniformMatrix4fv(projectionLocation, false, projectionMatrix)
			gl.uniformMatrix4fv(modelLocation, false, modelMatrix)
			gl.uniformMatrix3fv(normalMatrixLocation, false, normalMatrix3)
			gl.uniform3fv(baseColorLocation, new Float32Array(baseColor))

			gl.drawElements(gl.TRIANGLES, sphere.indices.length, gl.UNSIGNED_SHORT, 0)

			requestAnimationFrame(render)
		}

		requestAnimationFrame(render)
	</script>
</body>
</html>
